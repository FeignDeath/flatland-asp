#include <incmode>.
#const imin = 1.


#program base.
% agents
agent(A) :- initialstate(A,_,_).

% corresponding movement to every direction
movement((1,0),"S").movement((-1,0),"N").movement((0,1),"E").movement((0,-1),"W").

% direction changes with turns
left("N","W").left("W","S").left("S","E").left("E","N").
right("N","E").right("E","S").right("S","W").right("W","N").


#program step(t).
%% path generation
% choose a time for an agent to spawn, whereat he appears in the next timestep
{starttime(A,t)} :- initialstate(A,_,T), t>=T.
state(A,(P,D),t) :- initialstate(A,(P,D),_), starttime(A,t-1).

% an agent may take an allowed move if neither goal nor horizon is reached
{state(A,((X+X',Y+Y'),D2),t): movement((X',Y'),D2), transition((X,Y),(D1,D2))} :- state(A,((X,Y),D1),t-1), not target(A,(X,Y),_).
% an agent may wait a timestep if neither goal nor horizon is reached
{state(A,(P,D),t)} :- state(A,(P,D),t-1), not target(A,P,_).
% only one agent per timestep
:- 2 {state(A,_,t)}, agent(A).


%% constraints
% set goal if a reached it
goal(A,t) :- state(A,(P,_),t), target(A,P,_).

% collisions are forbidden
:- state(A1,(P,_),t), state(A2,(P,_),t), A1<A2.

% swapping is forbidden
:- state(A1,(P1,_),t-1), state(A1,(P2,_),t), state(A2,(P2,_),t-1), state(A2,(P1,_),t), A1<A2.

%% additional atom used to determine actions in the output
isTurn(A,t) :- state(A,(P,D1),t-1), state(A,(_,D2),t), D1!=D2, 2 {transition(P,(D1,_))}.


#program check(t).
% only one starttime per agent
:- starttime(A,T1), starttime(A,T2), T1<T2, query(t).

% the goal must be reached
:- agent(A), not goal(A,_), query(t), query(t).


%% output
#show.

% startorder
#show outputaction(A,2,T) : starttime(A,T).

% if an agent stays at the same vertex for the first time a stop action is generated
#show outputaction(A,4,T) : not state(A,P,T-1), state(A,P,T), state(A,P,T+1), state(A,_,T-1).

% if the agent stays longer than one timesteps at the start a stop action is necessary after spawning or else he moves automatically
#show outputaction(A,4,T) : not state(A,_,T-1), state(A,P,T), state(A,P,T+1).

% actions 1 and 3 (left and right turns) are only necessary, if multiple options exist otherwise the trains follows the rails
#show outputaction(A,1,T) : state(A,(P,D1),T), state(A,(_,D2),T+1), left(D1,D2) , 2 {transition(P,(D1,_))}.
#show outputaction(A,3,T) : state(A,(P,D1),T), state(A,(_,D2),T+1), right(D1,D2), 2 {transition(P,(D1,_))}.

% if the train carries on after stopping an action to continue is given
% if it continues via a turn, that action is already generated by the above and works as an action on its own
#show outputaction(A,2,T) : state(A,P,T-1), state(A,P,T), not state(A,P,T+1), not isTurn(A,T+1), state(A,_,T+1).

#program base.